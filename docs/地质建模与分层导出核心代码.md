# 地质建模与分层导出 — 核心代码摘录

本文件摘录并精简了项目中用于地质建模（分层生成）与分层导出为 STL 的核心实现，便于阅读与二次开发。

说明：代码为精简可读版，保留核心流程与关键防护（如 NaN 处理、层间间隙修复、顶板生成、分层导出流程）。可直接拷贝到项目中作为参考实现。

---

## 1. 最小数据结构与助手函数

```python
from dataclasses import dataclass
import numpy as np
from typing import List, Dict, Tuple, Callable, Any

@dataclass
class BlockModel:
    name: str
    top_surface: np.ndarray
    bottom_surface: np.ndarray
    thickness_grid: np.ndarray


def build_grids(x_values: np.ndarray, y_values: np.ndarray, resolution: int) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
    """生成规则网格（XI, YI）并返回展开的坐标用于插值。"""
    xi = np.linspace(x_values.min(), x_values.max(), resolution)
    yi = np.linspace(y_values.min(), y_values.max(), resolution)
    XI, YI = np.meshgrid(xi, yi)
    xi_flat = XI.flatten()
    yi_flat = YI.flatten()
    return XI, YI, xi_flat, yi_flat


def interpolate_seam(x_points: np.ndarray, y_points: np.ndarray, thickness: np.ndarray,
                      xi: np.ndarray, yi: np.ndarray, method_callable: Callable) -> np.ndarray:
    """使用传入的插值函数进行插值，并对无效值做合理填充与截断。

    method_callable 应当接受 (x_points, y_points, thickness, xi, yi) 并返回长度为 len(xi) 的一维数组。
    """
    values = method_callable(x_points, y_points, thickness, xi, yi)
    # 假定 grid 是平方展开（用于简化示例）
    n = int(np.sqrt(len(xi)))
    values = np.asarray(values).reshape((n, n))

    # NaN/Inf 填充为厚度中位数或经验值，避免厚度=0 导致层间重叠
    invalid_mask = ~np.isfinite(values)
    if np.any(invalid_mask):
        fill_value = float(np.median(thickness)) if len(thickness) > 0 else 1.0
        values = np.where(np.isfinite(values), values, fill_value)

    return np.clip(values, 0.0, None)
```

---

## 2. 建模主流程（分层生成）

简化版本的 `build_block_models` 核心逻辑：

```python
def build_block_models(merged_df, seam_column: str, x_col: str, y_col: str, thickness_col: str,
                       selected_seams: List[str], method_callable: Callable,
                       resolution: int = 150, base_level: float = 0.0, gap_value: float = 0.5) -> Tuple[List[BlockModel], List[str], Tuple[np.ndarray, np.ndarray]]:
    """为每个选定的煤层/岩层生成 BlockModel（顶面、底面、厚度网格）。

    - merged_df: 包含钻孔/采样点的 DataFrame
    - method_callable: 插值实现（可传 griddata/kriging 包装函数）
    """
    import numpy as np

    # 构建网格
    XI, YI, xi_flat, yi_flat = build_grids(merged_df[x_col].values, merged_df[y_col].values, resolution)

    block_models = []
    skipped = []
    current_base_surface = np.full(XI.shape, float(base_level), dtype=float)

    for seam_name in selected_seams:
        seam_df = merged_df[merged_df[seam_column] == seam_name]
        if seam_df.empty:
            skipped.append(f"{seam_name} (无数据)")
            continue

        x_points = seam_df[x_col].astype(float).values
        y_points = seam_df[y_col].astype(float).values
        thickness_points = seam_df[thickness_col].astype(float).values

        # 插值并处理无效值
        thickness_grid = interpolate_seam(x_points, y_points, thickness_points, xi_flat, yi_flat, method_callable)

        # 计算顶面和底面
        bottom_surface = current_base_surface.copy()
        top_surface = bottom_surface + thickness_grid

        # 防止自身交错：如果 top_min < bottom_max, 增加厚度
        top_min = float(np.nanmin(top_surface))
        bottom_max = float(np.nanmax(bottom_surface))
        if top_min < bottom_max:
            needed = bottom_max - top_min + 2.0
            thickness_grid = np.maximum(thickness_grid, needed)
            top_surface = bottom_surface + thickness_grid

        block_models.append(BlockModel(name=str(seam_name), top_surface=top_surface, bottom_surface=bottom_surface, thickness_grid=thickness_grid))

        # 将当前顶面作为下一层的底面（可加 gap_value）
        current_base_surface = top_surface
        if gap_value:
            current_base_surface = current_base_surface + float(gap_value)

    return block_models, skipped, (XI, YI)
```

要点说明：
- 对插值结果中的 NaN/Inf 做明确填充，避免厚度为零。
- 按自然顺序累加：`current_base_surface` 从基底开始，逐层向上累加，最终 `block_models` 的顺序是从底到顶。

---

## 3. 分层 STL 导出（核心流程）

下面给出导出器 `LayeredSTLExporter` 的精简核心，包含：修复层间重叠、生成顶板、导出各层 STL、生成 manifest 与 FISH 脚本并打包。

```python
import os, json, zipfile
import numpy as np
from typing import List, Dict

class LayeredSTLExporter:
    def __init__(self, stl_exporter):
        self.stl_exporter = stl_exporter  # 负责单层三角化与写文件

    def _fix_layer_overlap(self, layers: List[Dict], min_gap: float = 0.5):
        """检测并修复相邻层间的重叠（将下层顶面提升以保证间隙）。"""
        for i in range(len(layers) - 1):
            lower = layers[i]
            upper = layers[i+1]
            lower_top = np.array(lower['top_surface'])
            upper_bottom = np.array(upper['bottom_surface'])
            gap = upper_bottom - lower_top
            min_gap_val = np.nanmin(gap)
            if min_gap_val < min_gap:
                # 将上层底面调整，使得间隙至少为 min_gap
                adjust = (min_gap - min_gap_val)
                upper['bottom_surface'] = upper_bottom + adjust
                upper['top_surface'] = upper['top_surface'] + adjust

    def _create_top_plate_layer(self, layers: List[Dict], top_plate_thickness: float = 10.0) -> Dict:
        """基于最顶层（列表末尾）生成一个平顶的顶板层，并返回该层的数据结构。"""
        if not layers:
            raise ValueError("无法创建顶板: 地层为空")

        top_layer = layers[-1]
        grid_x = np.array(top_layer['grid_x'])
        grid_y = np.array(top_layer['grid_y'])
        top_surface_z = np.array(top_layer.get('top_surface') if 'top_surface' in top_layer else top_layer['grid_z'])

        max_z = float(np.nanmax(top_surface_z))
        top_plate = {
            'name': '顶板',
            'grid_x': grid_x,
            'grid_y': grid_y,
            'bottom_surface': top_surface_z.copy(),
            'top_surface': np.full_like(top_surface_z, max_z + top_plate_thickness)
        }
        return top_plate

    def export_layered(self, layers: List[Dict], out_zip_path: str, options: Dict = None) -> str:
        """将每层导出为单独 STL 并打包。"""
        if options is None:
            options = {}

        if not layers:
            raise ValueError("没有地层可导出")

        # 可选：自动追加顶板（追加到末尾，因 layers 顺序为从底到顶）
        if options.get('add_top_plate', True):
            top_plate_thickness = options.get('top_plate_thickness', 10.0)
            top_plate = self._create_top_plate_layer(layers, top_plate_thickness)
            layers.append(top_plate)

        # 修复层间重叠
        self._fix_layer_overlap(layers, min_gap=options.get('min_layer_gap', 0.5))

        manifest = {'layers': [], 'export_time': str(datetime.now()), 'total_layers': len(layers)}

        tmp_dir = os.path.splitext(out_zip_path)[0] + '_tmp'
        os.makedirs(tmp_dir, exist_ok=True)

        for idx, layer in enumerate(layers, start=1):
            filename = f"{idx:02d}_{layer['name']}.stl"
            filepath = os.path.join(tmp_dir, filename)
            # 调用外部 stl 导出逻辑（负责三角化、法向、写文件）
            self.stl_exporter.export_layer_to_stl(layer, filepath)
            manifest['layers'].append({'name': layer['name'], 'filename': filename})

        # 生成 FISH 脚本（简化）
        fish_path = os.path.join(tmp_dir, 'import_to_flac3d.fish')
        with open(fish_path, 'w', encoding='utf-8') as f:
            last_layer_num = len([l for l in manifest['layers'] if l.get('filename')])
            f.write(f"; 自动导入脚本\n; 顶板为 Layer {last_layer_num:02d}（若存在）\n")
            for i, li in enumerate(manifest['layers'], start=1):
                f.write(f"geometry import stl \"{li['filename']}\"\n")
                f.write("zone generate from-geometry edge-length 50.0\n\n")

        # 打包
        with zipfile.ZipFile(out_zip_path, 'w', zipfile.ZIP_DEFLATED) as zf:
            for f in os.listdir(tmp_dir):
                zf.write(os.path.join(tmp_dir, f), arcname=f)

        return out_zip_path
```

要点：
- `layers` 在系统中约定为从底到顶（第一个元素最底），因此创建顶板时要基于 `layers[-1]` 并追加到末尾。
- 在导出前统一运行 `_fix_layer_overlap` 能降低 FLAC3D 导入时出现的“硬边被切割”类错误。

---

## 4. 使用建议与测试步骤

- 在单元测试中构造 2-3 层简单高度场（小网格）验证 `build_block_models` 输出：顶面、底面不交叠。
- 用小范围网格（resolution 50）先导出测试 STL，检查单层在 FLAC3D 中能否成功导入并生成网格。
- 若出现导入边界错误，逐层在 FISH 脚本中注释排查。

---

如果你需要，我可以：
- 将此文档改为英文版。
- 基于当前仓库自动生成一套最小可运行的单元测试（pytest）。
- 把精简版代码直接同步回某个模块作为 `core_refactor.py`。

---

文件结束。
