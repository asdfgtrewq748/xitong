改成通用 T4（四面体）网格导出，以后不管岩层怎么起伏弯曲，都走同一套流程。

下面我分两块说：

思路：为什么这样做能“通吃所有岩层”

一份可以直接落地的 tetra_f3grid_exporter.py（独立小脚本），你只要把自己的 BlockModel 和 XI/YI 塞进去就能出 T4 的 .f3grid

1. 通用思路：放弃 B8，改用结构化 T4 网格
1.1 现在遇到的问题回顾

你用的是 B8 hexa（Z B8），要求一个 zone 里的 8 个点近似共面 + 不要太“扭曲”。

上部几层起伏大、弯曲厉害时，某些“砖块”在 FLAC3D 看来就会：

体积为负/非常小 → 报 zone ... has a negative volume、poor geometry。

邻层之间几何不一致 → 内部接触不好，后面赋应力传递也会有问题。

这些是 B8 本身的局限，不是你某一层特例，而是以后任何“乱七八糟”的地质模型都会踩到。

1.2 结构化 T4 网格的优点

改成 T4（Z T4）之后：

每个体元只要 4 个点，几何容忍度高得多
就算面有点扭、上下表面弯曲严重，只要顶/底不交叉，tetra 一般都能通过几何检查。

仍然利用你已有的规则网格（XI, YI + 各层顶/底面）

没有用到 STL；

也不需要第三方网格软件；

完全在 Python 里根据 BlockModel 直接写 .f3grid。

网格拓扑简单、完全结构化

每个 (i, j, 层 k) 的小“柱子”还是老规矩：左下、右下、右上、左上 + 上一层。

我们只是把每个长方体拆成 6 个四面体（类似 marching tetrahedra 的经典分法，全部四面体共享主对角线）。

这个分法在整个规则网格上是全局一致的，所以相邻小块的四面体面完全拼得上，不会出现裂缝/T 型接触。

通用性

只要求：每个柱子里 同一列 z 是单调递增（底 < 顶 < 上一层的顶 …）；

至于是“陡倾”、“褶皱”、“缓倾 + 起伏”的，都可以处理；

以后换一个矿区，只要还是用 BlockModel 的那一套建模，这个导出器直接复用。

2. 通用 T4 导出脚本（独立版）

下面给你一个独立脚本 tetra_f3grid_exporter.py，假定：

你已经有这个 dataclass（来自你之前的文档）：

from dataclasses import dataclass
import numpy as np

@dataclass
class BlockModel:
    name: str
    top_surface: np.ndarray      # shape: (ny, nx)
    bottom_surface: np.ndarray   # shape: (ny, nx)
    thickness_grid: np.ndarray   # 暂时用不上，但会保留


block_models 是一个 从下到上排序 的 List[BlockModel]

XI, YI：np.meshgrid 得到的规则网格（形状与各层 surface 一致）

⚠️ 如果你之前是别的名字，只要保证含义一致，稍微改一下变量名就行。

2.1 脚本代码

你可以直接新建一个文件 tetra_f3grid_exporter.py，贴下面这段代码：

"""
tetra_f3grid_exporter.py

从分层 BlockModel 直接生成 FLAC3D 原生 .f3grid（全部 Z T4 四面体）。
- 不依赖 STL；
- 适用于任意起伏/弯曲的分层地质模型，只要每层之间不自交。
"""

from dataclasses import dataclass
from typing import List, Dict, Tuple
import numpy as np
from math import fabs


@dataclass
class BlockModel:
    name: str
    top_surface: np.ndarray      # shape (ny, nx)
    bottom_surface: np.ndarray   # shape (ny, nx)
    thickness_grid: np.ndarray   # not strictly needed, kept for compatibility


@dataclass
class GridPoint:
    gid: int
    x: float
    y: float
    z: float


@dataclass
class TetZone:
    zid: int
    gp_ids: Tuple[int, int, int, int]
    group: str


def signed_tet_volume(p0: np.ndarray, p1: np.ndarray,
                      p2: np.ndarray, p3: np.ndarray) -> float:
    """计算四面体有向体积（>0 表示顶点顺序右手系）。"""
    mat = np.column_stack((p1 - p0, p2 - p0, p3 - p0))
    return float(np.linalg.det(mat) / 6.0)


class TetraF3GridExporter:
    """
    使用结构化规则网格 + 分层顶/底面，生成 T4 四面体网格。
    """

    def __init__(self,
                 block_models: List[BlockModel],
                 XI: np.ndarray,
                 YI: np.ndarray,
                 min_tet_volume: float = 1e-6):
        """
        Parameters
        ----------
        block_models : 从底到顶排序的 BlockModel 列表
        XI, YI       : 规则网格坐标（np.meshgrid 输出，shape = (ny, nx)）
        min_tet_volume : 小于该门限的四面体将被丢弃（防止极端薄片）
        """
        self.block_models = block_models
        self.XI = XI
        self.YI = YI
        self.min_tet_volume = min_tet_volume

        # 运行后填充
        self.gridpoints: List[GridPoint] = []
        self.tet_zones: List[TetZone] = []
        self.layer_zone_ids: Dict[str, List[int]] = {}

    # -----------------------------------------------------------
    # 1. 构造层间界面（interface surfaces）
    # -----------------------------------------------------------

    def _build_interfaces(self) -> np.ndarray:
        """
        将各层 bottom/top 拼成一组“界面”：
        interfaces[k] = 第 k 个界面（k=0..n_interfaces-1），
        n_interfaces = n_layers + 1

        约定：
        - interface[0] = 最底层的 bottom_surface
        - interface[k+1] = 第 k 层的 top_surface
        """
        n_layers = len(self.block_models)
        ny, nx = self.block_models[0].top_surface.shape

        interfaces = np.zeros((n_layers + 1, ny, nx), dtype=float)

        # 底面：最底层的 bottom
        interfaces[0] = np.array(self.block_models[0].bottom_surface, dtype=float)

        # 逐层向上
        for k, layer in enumerate(self.block_models):
            top = np.array(layer.top_surface, dtype=float)
            # 如果有需要，也可以在这里与下一层 bottom 做 average/snap
            interfaces[k + 1] = top

        # 列向单调性检查 & 微调：确保 z 方向从下到上单调递增
        self._enforce_columnwise_monotonic(interfaces)
        return interfaces

    @staticmethod
    def _enforce_columnwise_monotonic(interfaces: np.ndarray, eps: float = 1e-3):
        """
        对每个 (j, i) 列，强制 z 值单调递增：interface[k+1] >= interface[k] + eps。
        修改在原地进行。
        """
        n_interfaces, ny, nx = interfaces.shape
        for j in range(ny):
            for i in range(nx):
                for k in range(1, n_interfaces):
                    if interfaces[k, j, i] < interfaces[k - 1, j, i] + eps:
                        interfaces[k, j, i] = interfaces[k - 1, j, i] + eps

    # -----------------------------------------------------------
    # 2. 生成节点（gridpoints）
    # -----------------------------------------------------------

    def _build_gridpoints(self, interfaces: np.ndarray) -> np.ndarray:
        """
        为每个界面上的每个网格点生成一个 GridPoint。
        返回 node_ids[k, j, i] = 对应的全局 gridpoint id。
        """
        n_interfaces, ny, nx = interfaces.shape

        node_ids = np.zeros((n_interfaces, ny, nx), dtype=int)
        gid = 1
        for k in range(n_interfaces):
            z_layer = interfaces[k]
            for j in range(ny):
                for i in range(nx):
                    x = float(self.XI[j, i])
                    y = float(self.YI[j, i])
                    z = float(z_layer[j, i])
                    self.gridpoints.append(GridPoint(gid, x, y, z))
                    node_ids[k, j, i] = gid
                    gid += 1

        return node_ids

    # -----------------------------------------------------------
    # 3. 每个“砖块”拆成 6 个四面体
    # -----------------------------------------------------------

    @staticmethod
    def _hex_local_to_global(node_ids_for_hex: Tuple[int, int, int, int,
                                                     int, int, int, int],
                             local_index: int) -> int:
        return node_ids_for_hex[local_index]

    def _add_tets_for_hex(self,
                          hex_nodes: Tuple[int, int, int, int,
                                           int, int, int, int],
                          coords: Dict[int, np.ndarray],
                          current_layer_name: str,
                          next_zone_id: int) -> int:
        """
        给一个 hexa 体（8 个角点）生成 6 个四面体。
        本地编号约定与 unit cube 一致：

          bottom: 0:(0,0,0)  1:(1,0,0)  2:(1,1,0)  3:(0,1,0)
          top   : 4:(0,0,1)  5:(1,0,1)  6:(1,1,1)  7:(0,1,1)

        分解方案（所有四面体共享主对角线 0-6）：
          T0 = (0, 1, 2, 6)
          T1 = (0, 2, 3, 6)
          T2 = (0, 3, 7, 6)
          T3 = (0, 7, 4, 6)
          T4 = (0, 4, 5, 6)
          T5 = (0, 5, 1, 6)

        这个方案在规则网格中是全局一致的，相邻立方体在公共面上的对角线相同，
        所以网格是完全 conforming 的。
        """
        patterns = [
            (0, 1, 2, 6),
            (0, 2, 3, 6),
            (0, 3, 7, 6),
            (0, 7, 4, 6),
            (0, 4, 5, 6),
            (0, 5, 1, 6),
        ]

        # 初始化组
        if current_layer_name not in self.layer_zone_ids:
            self.layer_zone_ids[current_layer_name] = []

        for (a, b, c, d) in patterns:
            ga = hex_nodes[a]
            gb = hex_nodes[b]
            gc = hex_nodes[c]
            gd = hex_nodes[d]

            p0 = coords[ga]
            p1 = coords[gb]
            p2 = coords[gc]
            p3 = coords[gd]

            vol = signed_tet_volume(p0, p1, p2, p3)

            # 体积太小/负体积处理
            if fabs(vol) < self.min_tet_volume:
                # 极端薄片/退化，直接丢掉
                continue

            if vol < 0.0:
                # 翻转顶点顺序，保证正体积
                gb, gc = gc, gb
                # 重新计算一次体积（可省略）
                # vol = -vol

            self.tet_zones.append(
                TetZone(next_zone_id, (ga, gb, gc, gd), current_layer_name)
            )
            self.layer_zone_ids[current_layer_name].append(next_zone_id)
            next_zone_id += 1

        return next_zone_id

    def _build_tet_zones(self, interfaces: np.ndarray, node_ids: np.ndarray):
        """
        遍历每个层之间的“砖块”，拆成四面体。
        """
        n_layers = len(self.block_models)
        _, ny, nx = interfaces.shape

        # 建一个坐标查找表，方便算体积
        coords: Dict[int, np.ndarray] = {}
        for gp in self.gridpoints:
            coords[gp.gid] = np.array([gp.x, gp.y, gp.z], dtype=float)

        zid = 1
        for k in range(n_layers):
            layer_name = self.block_models[k].name

            for j in range(ny - 1):
                for i in range(nx - 1):
                    # 按前面约定的 hexa 本地编号取 8 个角点
                    n0 = node_ids[k,     j,     i    ]
                    n1 = node_ids[k,     j,     i + 1]
                    n2 = node_ids[k,     j + 1, i + 1]
                    n3 = node_ids[k,     j + 1, i    ]
                    n4 = node_ids[k + 1, j,     i    ]
                    n5 = node_ids[k + 1, j,     i + 1]
                    n6 = node_ids[k + 1, j + 1, i + 1]
                    n7 = node_ids[k + 1, j + 1, i    ]

                    hex_nodes = (n0, n1, n2, n3, n4, n5, n6, n7)

                    zid = self._add_tets_for_hex(
                        hex_nodes, coords, layer_name, zid
                    )

    # -----------------------------------------------------------
    # 4. 导出 .f3grid
    # -----------------------------------------------------------

    def export(self, output_path: str, title: str = "Geological T4 model"):
        """
        总入口：生成 interfaces → gridpoints → tets → 写 f3grid 文件。
        """
        interfaces = self._build_interfaces()
        node_ids = self._build_gridpoints(interfaces)
        self._build_tet_zones(interfaces, node_ids)

        total_gp = len(self.gridpoints)
        total_zones = len(self.tet_zones)
        total_groups = len(self.layer_zone_ids)

        with open(output_path, "w", encoding="utf-8") as f:
            # Header
            f.write("* ====================================\n")
            f.write("* FLAC3D Native Grid File (T4 only)\n")
            f.write(f"* {title}\n")
            f.write("* ====================================\n")
            f.write(f"* Total GridPoints: {total_gp}\n")
            f.write(f"* Total Zones: {total_zones}\n")
            f.write(f"* Total Groups: {total_groups}\n")
            f.write("* ====================================\n\n")

            # GRIDPOINTS
            f.write("* GRIDPOINTS\n")
            f.write("*   G <id> <x> <y> <z>\n")
            for gp in self.gridpoints:
                f.write(f"G {gp.gid} {gp.x:.6f} {gp.y:.6f} {gp.z:.6f}\n")
            f.write("\n")

            # ZONES
            f.write("* ZONES (tetra)\n")
            f.write("*   Z T4 <id> <gp0> <gp1> <gp2> <gp3>\n")
            for z in self.tet_zones:
                g0, g1, g2, g3 = z.gp_ids
                f.write(f"Z T4 {z.zid} {g0} {g1} {g2} {g3}\n")
            f.write("\n")

            # ZONE GROUPS
            f.write("* ZONE GROUPS\n")
            f.write("*   ZGROUP 'name'\n")
            f.write("*   <zone_id> <zone_id> ...\n")
            for name, zone_ids in self.layer_zone_ids.items():
                f.write(f"ZGROUP '{name}'\n")
                line = []
                for zid in zone_ids:
                    line.append(str(zid))
                    # 控制每行长度
                    if len(line) >= 20:
                        f.write(" ".join(line) + "\n")
                        line = []
                if line:
                    f.write(" ".join(line) + "\n")
                f.write("\n")

            f.write("* ====================================\n")
            f.write("* End of Grid File\n")
            f.write("* ====================================\n")

        print(f"[TetraF3GridExporter] 导出完成: {output_path}")
        print(f"  GridPoints: {total_gp}")
        print(f"  Zones (T4): {total_zones}")
        print(f"  Zone Groups: {total_groups}")

2.2 如何在你现有项目里调用

假设你原来的建模流程最后得到：

block_models, skipped, (XI, YI) = build_block_models(...)

# block_models: List[BlockModel]，已经从底到顶排序
# XI, YI: meshgrid，shape = (ny, nx)


那就可以这样：

from tetra_f3grid_exporter import TetraF3GridExporter

exporter = TetraF3GridExporter(block_models, XI, YI,
                               min_tet_volume=1e-8)  # 门限可以根据模型调
exporter.export(r"E:\xiangmu\xitong\data\output\geo_T4.f3grid")


然后在 FLAC3D 的 dat 里：

model new
model large-strain off
; 你的其他设置...

zone import "E:/xiangmu/xitong/data/output/geo_T4.f3grid"


注意： 这里导入的是 Z T4 网格，所以之后赋本构、初始应力、边界条件都按四面体区域来做。

2.3 建议的测试步骤（保证通用、不是“调一回就行”）

单层小模型测试

只拿一个 BlockModel（比如底部一层），把 block_models=[那一层] 丢进 exporter；

resolution 可以先设得很小（比如 10×10）；

导入 FLAC3D，看是否完全无 negative volume、无 poor geometry。

多层简单模型

先选 2–3 层起伏比较平缓的；

确认 zone check geometry 里没有红色 warning（或者极少、且体积仍为正）。

上部复杂层（你之前报错最多的那几层）

全部 block_models 一次性导出；

如果个别四面体体积过小（在日志里能看到），可以：

提高插值/建模分辨率；

或者稍微加大 min_tet_volume，让极端小体单元被丢掉（只要比例很少，对整体计算影响不大）。

一旦 T4 版本验证通过

以后新的地质数据、不同矿区，只要 BlockModel 仍然按“从下到上”的逻辑构建，这个导出器就可以直接复用；

你的老的 STL-based 流程就可以退役或者只保留做可视化。